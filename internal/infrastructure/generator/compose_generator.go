package generator

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/yourorg/grund/internal/application/ports"
	"github.com/yourorg/grund/internal/domain/infrastructure"
	"github.com/yourorg/grund/internal/domain/service"
)

// ComposeGeneratorImpl implements ComposeGenerator
type ComposeGeneratorImpl struct {
	outputPath string
}

// NewComposeGenerator creates a new compose generator
func NewComposeGenerator(outputPath string) ports.ComposeGenerator {
	return &ComposeGeneratorImpl{
		outputPath: outputPath,
	}
}

// Generate generates a docker-compose.yaml file
func (g *ComposeGeneratorImpl) Generate(services []*service.Service, infra infrastructure.InfrastructureRequirements) (string, error) {
	// Ensure directory exists
	dir := filepath.Dir(g.outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return "", fmt.Errorf("failed to create directory: %w", err)
	}

	file, err := os.Create(g.outputPath)
	if err != nil {
		return "", fmt.Errorf("failed to create compose file: %w", err)
	}
	defer file.Close()

	// TODO: Generate full docker-compose content
	// This is a placeholder - full implementation would use templates
	fmt.Fprintf(file, "# AUTO-GENERATED by grund - DO NOT EDIT\n")
	fmt.Fprintf(file, "version: \"3.8\"\n\n")
	fmt.Fprintf(file, "# Services: %d\n", len(services))
	fmt.Fprintf(file, "# Infrastructure: %v\n", infra)

	return g.outputPath, nil
}
