package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/vivekkundariya/grund/internal/application/ports"
	"github.com/vivekkundariya/grund/internal/domain/infrastructure"
	"github.com/vivekkundariya/grund/internal/domain/service"
	"gopkg.in/yaml.v3"
)

// ComposeGeneratorImpl implements ComposeGenerator
type ComposeGeneratorImpl struct {
	outputPath  string
	envResolver ports.EnvironmentResolver
}

// NewComposeGenerator creates a new compose generator
func NewComposeGenerator(outputPath string) ports.ComposeGenerator {
	return &ComposeGeneratorImpl{
		outputPath:  outputPath,
		envResolver: NewEnvironmentResolver(),
	}
}

// ComposeFile represents a docker-compose.yaml structure
type ComposeFile struct {
	Version  string                    `yaml:"version"`
	Services map[string]ComposeService `yaml:"services"`
	Networks map[string]ComposeNetwork `yaml:"networks,omitempty"`
	Volumes  map[string]ComposeVolume  `yaml:"volumes,omitempty"`
}

// ComposeService represents a service in docker-compose
type ComposeService struct {
	Image         string            `yaml:"image,omitempty"`
	Build         *ComposeBuild     `yaml:"build,omitempty"`
	Ports         []string          `yaml:"ports,omitempty"`
	Environment   map[string]string `yaml:"environment,omitempty"`
	Volumes       []string          `yaml:"volumes,omitempty"`
	DependsOn     interface{}       `yaml:"depends_on,omitempty"`
	Networks      []string          `yaml:"networks,omitempty"`
	Healthcheck   *ComposeHealth    `yaml:"healthcheck,omitempty"`
	Command       []string          `yaml:"command,omitempty"`
	ContainerName string            `yaml:"container_name,omitempty"`
}

// ComposeBuild represents build configuration
type ComposeBuild struct {
	Context    string `yaml:"context"`
	Dockerfile string `yaml:"dockerfile"`
}

// ComposeHealth represents healthcheck configuration
type ComposeHealth struct {
	Test        []string `yaml:"test"`
	Interval    string   `yaml:"interval"`
	Timeout     string   `yaml:"timeout"`
	Retries     int      `yaml:"retries"`
	StartPeriod string   `yaml:"start_period,omitempty"`
}

// ComposeNetwork represents a network
type ComposeNetwork struct {
	Driver string `yaml:"driver,omitempty"`
}

// ComposeVolume represents a volume
type ComposeVolume struct {
	Driver string `yaml:"driver,omitempty"`
}

// DependsOnCondition for service dependencies with conditions
type DependsOnCondition struct {
	Condition string `yaml:"condition"`
}

// Generate generates a docker-compose.yaml file
func (g *ComposeGeneratorImpl) Generate(services []*service.Service, infra infrastructure.InfrastructureRequirements) (string, error) {
	// Ensure directory exists
	dir := filepath.Dir(g.outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return "", fmt.Errorf("failed to create directory: %w", err)
	}

	// Build the compose file
	compose := &ComposeFile{
		Version:  "3.8",
		Services: make(map[string]ComposeService),
		Networks: map[string]ComposeNetwork{
			"grund-network": {Driver: "bridge"},
		},
		Volumes: make(map[string]ComposeVolume),
	}

	// Build environment context for variable resolution
	envContext := g.buildEnvironmentContext(services, infra)

	// Add infrastructure services
	g.addInfrastructureServices(compose, infra)

	// Add application services
	if err := g.addApplicationServices(compose, services, envContext); err != nil {
		return "", err
	}

	// Write to file
	file, err := os.Create(g.outputPath)
	if err != nil {
		return "", fmt.Errorf("failed to create compose file: %w", err)
	}
	defer file.Close()

	// Add header comment
	fmt.Fprintf(file, "# AUTO-GENERATED by grund - DO NOT EDIT\n")
	fmt.Fprintf(file, "# Regenerate with: grund up <services>\n\n")

	encoder := yaml.NewEncoder(file)
	encoder.SetIndent(2)
	if err := encoder.Encode(compose); err != nil {
		return "", fmt.Errorf("failed to write compose file: %w", err)
	}

	return g.outputPath, nil
}

func (g *ComposeGeneratorImpl) buildEnvironmentContext(services []*service.Service, infra infrastructure.InfrastructureRequirements) ports.EnvironmentContext {
	ctx := ports.NewDefaultEnvironmentContext()

	// Add infrastructure contexts
	if infra.Postgres != nil {
		ctx.Infrastructure["postgres"] = ports.InfrastructureContext{
			Host:     "postgres",
			Port:     5432,
			Database: infra.Postgres.Database,
			Username: "postgres",
			Password: "postgres",
		}
	}

	if infra.MongoDB != nil {
		ctx.Infrastructure["mongodb"] = ports.InfrastructureContext{
			Host:     "mongodb",
			Port:     27017,
			Database: infra.MongoDB.Database,
		}
	}

	if infra.Redis != nil {
		ctx.Infrastructure["redis"] = ports.InfrastructureContext{
			Host: "redis",
			Port: 6379,
		}
	}

	// Add SQS queue contexts
	if infra.SQS != nil {
		for _, queue := range infra.SQS.Queues {
			ctx.SQS[queue.Name] = ports.QueueContext{
				Name: queue.Name,
				URL:  fmt.Sprintf("%s/000000000000/%s", ctx.LocalStack.Endpoint, queue.Name),
				ARN:  fmt.Sprintf("arn:aws:sqs:%s:000000000000:%s", ctx.LocalStack.Region, queue.Name),
				DLQ:  fmt.Sprintf("%s/000000000000/%s-dlq", ctx.LocalStack.Endpoint, queue.Name),
			}
		}
	}

	// Add SNS topic contexts
	if infra.SNS != nil {
		for _, topic := range infra.SNS.Topics {
			ctx.SNS[topic.Name] = ports.TopicContext{
				Name: topic.Name,
				ARN:  fmt.Sprintf("arn:aws:sns:%s:000000000000:%s", ctx.LocalStack.Region, topic.Name),
			}
		}
	}

	// Add S3 bucket contexts
	if infra.S3 != nil {
		for _, bucket := range infra.S3.Buckets {
			ctx.S3[bucket.Name] = ports.BucketContext{
				Name: bucket.Name,
				URL:  fmt.Sprintf("%s/%s", ctx.LocalStack.Endpoint, bucket.Name),
			}
		}
	}

	// Add service contexts
	for _, svc := range services {
		ctx.Services[svc.Name] = ports.ServiceContext{
			Host: svc.Name, // Container name in Docker network
			Port: svc.Port.Value(),
			Config: map[string]interface{}{
				"postgres.database": getServicePostgresDB(svc),
				"mongodb.database":  getServiceMongoDB(svc),
			},
		}
	}

	return ctx
}

func (g *ComposeGeneratorImpl) addInfrastructureServices(compose *ComposeFile, infra infrastructure.InfrastructureRequirements) {
	// Add PostgreSQL
	if infra.Postgres != nil {
		compose.Services["postgres"] = ComposeService{
			Image:         "postgres:15-alpine",
			ContainerName: "grund-postgres",
			Ports:         []string{"5432:5432"},
			Environment: map[string]string{
				"POSTGRES_USER":     "postgres",
				"POSTGRES_PASSWORD": "postgres",
				"POSTGRES_DB":       infra.Postgres.Database,
			},
			Volumes:  []string{"postgres-data:/var/lib/postgresql/data"},
			Networks: []string{"grund-network"},
			Healthcheck: &ComposeHealth{
				Test:     []string{"CMD-SHELL", "pg_isready -U postgres"},
				Interval: "5s",
				Timeout:  "5s",
				Retries:  5,
			},
		}
		compose.Volumes["postgres-data"] = ComposeVolume{}
	}

	// Add MongoDB
	if infra.MongoDB != nil {
		compose.Services["mongodb"] = ComposeService{
			Image:         "mongo:6",
			ContainerName: "grund-mongodb",
			Ports:         []string{"27017:27017"},
			Environment: map[string]string{
				"MONGO_INITDB_DATABASE": infra.MongoDB.Database,
			},
			Volumes:  []string{"mongodb-data:/data/db"},
			Networks: []string{"grund-network"},
			Healthcheck: &ComposeHealth{
				Test:     []string{"CMD", "mongosh", "--eval", "db.adminCommand('ping')"},
				Interval: "5s",
				Timeout:  "5s",
				Retries:  5,
			},
		}
		compose.Volumes["mongodb-data"] = ComposeVolume{}
	}

	// Add Redis
	if infra.Redis != nil {
		compose.Services["redis"] = ComposeService{
			Image:         "redis:7-alpine",
			ContainerName: "grund-redis",
			Ports:         []string{"6379:6379"},
			Networks:      []string{"grund-network"},
			Healthcheck: &ComposeHealth{
				Test:     []string{"CMD", "redis-cli", "ping"},
				Interval: "5s",
				Timeout:  "5s",
				Retries:  5,
			},
		}
	}

	// Add LocalStack if any AWS services are needed
	if infra.SQS != nil || infra.SNS != nil || infra.S3 != nil {
		services := []string{}
		if infra.SQS != nil {
			services = append(services, "sqs")
		}
		if infra.SNS != nil {
			services = append(services, "sns")
		}
		if infra.S3 != nil {
			services = append(services, "s3")
		}

		compose.Services["localstack"] = ComposeService{
			Image:         "localstack/localstack:latest",
			ContainerName: "grund-localstack",
			Ports:         []string{"4566:4566"},
			Environment: map[string]string{
				"SERVICES":           strings.Join(services, ","),
				"DEBUG":              "0",
				"AWS_DEFAULT_REGION": "us-east-1",
				"AWS_ACCOUNT_ID":     "000000000000",
				"DOCKER_HOST":        "unix:///var/run/docker.sock",
			},
			Volumes: []string{
				"/var/run/docker.sock:/var/run/docker.sock",
				"localstack-data:/var/lib/localstack",
			},
			Networks: []string{"grund-network"},
			Healthcheck: &ComposeHealth{
				Test:        []string{"CMD-SHELL", "curl -s http://localhost:4566/_localstack/health | grep -E '\"sqs\":\\s*\"(running|available)\"' || exit 1"},
				Interval:    "10s",
				Timeout:     "5s",
				Retries:     10,
				StartPeriod: "20s",
			},
		}
		compose.Volumes["localstack-data"] = ComposeVolume{}
	}
}

func (g *ComposeGeneratorImpl) addApplicationServices(compose *ComposeFile, services []*service.Service, envContext ports.EnvironmentContext) error {
	for _, svc := range services {
		// Build self context for this service
		selfContext := envContext
		selfContext.Self = ports.ServiceContext{
			Host: svc.Name,
			Port: svc.Port.Value(),
			Config: map[string]interface{}{
				"postgres.database": getServicePostgresDB(svc),
				"mongodb.database":  getServiceMongoDB(svc),
			},
		}

		// Resolve environment variables
		resolvedEnv := make(map[string]string)

		// Add static environment variables
		for k, v := range svc.Environment.Variables {
			resolvedEnv[k] = v
		}

		// Resolve environment references
		if len(svc.Environment.References) > 0 {
			resolved, err := g.envResolver.Resolve(svc.Environment.References, selfContext)
			if err != nil {
				return fmt.Errorf("failed to resolve env for %s: %w", svc.Name, err)
			}
			for k, v := range resolved {
				resolvedEnv[k] = v
			}
		}

		// Add AWS credentials if LocalStack is used
		if svc.RequiresInfrastructure("localstack") {
			resolvedEnv["AWS_ENDPOINT"] = selfContext.LocalStack.Endpoint
			resolvedEnv["AWS_REGION"] = selfContext.LocalStack.Region
			resolvedEnv["AWS_ACCESS_KEY_ID"] = selfContext.LocalStack.AccessKeyID
			resolvedEnv["AWS_SECRET_ACCESS_KEY"] = selfContext.LocalStack.SecretAccessKey
			resolvedEnv["AWS_ACCOUNT_ID"] = selfContext.LocalStack.AccountID
		}

		// Build depends_on with conditions
		dependsOn := g.buildDependsOn(svc)

		// Create compose service
		composeService := ComposeService{
			ContainerName: fmt.Sprintf("grund-%s", svc.Name),
			Environment:   resolvedEnv,
			Networks:      []string{"grund-network"},
			DependsOn:     dependsOn,
		}

		// Set build or image
		if svc.Build != nil {
			composeService.Build = &ComposeBuild{
				Context:    svc.Build.Context,
				Dockerfile: svc.Build.Dockerfile,
			}
		}

		// Set ports
		composeService.Ports = []string{fmt.Sprintf("%d:%d", svc.Port.Value(), svc.Port.Value())}

		// Set healthcheck
		if svc.Health.Endpoint != "" {
			composeService.Healthcheck = &ComposeHealth{
				Test:     []string{"CMD-SHELL", fmt.Sprintf("curl -sf http://localhost:%d%s || exit 1", svc.Port.Value(), svc.Health.Endpoint)},
				Interval: svc.Health.Interval.String(),
				Timeout:  svc.Health.Timeout.String(),
				Retries:  svc.Health.Retries,
			}
		}

		compose.Services[svc.Name] = composeService
	}

	return nil
}

func (g *ComposeGeneratorImpl) buildDependsOn(svc *service.Service) map[string]DependsOnCondition {
	dependsOn := make(map[string]DependsOnCondition)

	// Add infrastructure dependencies
	if svc.RequiresInfrastructure("postgres") {
		dependsOn["postgres"] = DependsOnCondition{Condition: "service_healthy"}
	}
	if svc.RequiresInfrastructure("mongodb") {
		dependsOn["mongodb"] = DependsOnCondition{Condition: "service_healthy"}
	}
	if svc.RequiresInfrastructure("redis") {
		dependsOn["redis"] = DependsOnCondition{Condition: "service_healthy"}
	}
	if svc.RequiresInfrastructure("localstack") {
		dependsOn["localstack"] = DependsOnCondition{Condition: "service_healthy"}
	}

	// Add service dependencies
	for _, dep := range svc.Dependencies.Services {
		dependsOn[dep.String()] = DependsOnCondition{Condition: "service_healthy"}
	}

	if len(dependsOn) == 0 {
		return nil
	}

	return dependsOn
}

// Helper functions
func getServicePostgresDB(svc *service.Service) string {
	if svc.Dependencies.Infrastructure.Postgres != nil {
		return svc.Dependencies.Infrastructure.Postgres.Database
	}
	return ""
}

func getServiceMongoDB(svc *service.Service) string {
	if svc.Dependencies.Infrastructure.MongoDB != nil {
		return svc.Dependencies.Infrastructure.MongoDB.Database
	}
	return ""
}
